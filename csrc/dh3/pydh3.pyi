from __future__ import annotations
import dh3
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['AbruptDhSolver', 'AbruptDhState', 'AbruptDhTraverser', 'AbruptPtttSolver', 'AbruptPtttState', 'AbruptPtttTraverser', 'Averager', 'AveragingStrategy', 'CfrConf', 'CfrSolver', 'CornerDhSolver', 'CornerDhState', 'CornerDhTraverser', 'DhSolver', 'DhState', 'DhTraverser', 'EvExpl', 'PtttSolver', 'PtttState', 'PtttTraverser']
class AbruptDhSolver:
    def __init__(self, arg0: AbruptDhTraverser, arg1: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class AbruptDhState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> AbruptDhState:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, arg0: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class AbruptDhTraverser:
    def __init__(self) -> None:
        ...
    def construct_uniform_strategies(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def ev_and_exploitability(self, arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, arg0: int) -> Averager:
        ...
    def parent_index_and_action(self, arg0: int, arg1: int) -> tuple[int, int]:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
    @property
    def NUM_INFOS_PL2(self) -> int:
        ...
class AbruptPtttSolver:
    def __init__(self, arg0: AbruptPtttTraverser, arg1: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class AbruptPtttState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> AbruptPtttState:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, arg0: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class AbruptPtttTraverser:
    def __init__(self) -> None:
        ...
    def construct_uniform_strategies(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def ev_and_exploitability(self, arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, arg0: int) -> Averager:
        ...
    def parent_index_and_action(self, arg0: int, arg1: int) -> tuple[int, int]:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
    @property
    def NUM_INFOS_PL2(self) -> int:
        ...
class Averager:
    def clear(self) -> None:
        ...
    def push(self, strategy: numpy.ndarray[numpy.float64], weight: float) -> None:
        ...
    def running_avg(self) -> numpy.ndarray[numpy.float64]:
        ...
class AveragingStrategy:
    """
    Members:
    
      UNIFORM
    
      LINEAR
    
      QUADRATIC
    """
    LINEAR: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.LINEAR: 1>
    QUADRATIC: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.QUADRATIC: 2>
    UNIFORM: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.UNIFORM: 0>
    __members__: typing.ClassVar[dict[str, AveragingStrategy]]  # value = {'UNIFORM': <AveragingStrategy.UNIFORM: 0>, 'LINEAR': <AveragingStrategy.LINEAR: 1>, 'QUADRATIC': <AveragingStrategy.QUADRATIC: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CfrConf:
    DCFR: typing.ClassVar[CfrConf]  # value = CfrConf(avg=quadratic, alternation=true, dcfr=true, rmplus=false, predictive=false)
    PCFRP: typing.ClassVar[CfrConf]  # value = CfrConf(avg=quadratic, alternation=true, dcfr=false, rmplus=true, predictive=true)
    alternation: bool
    avg: AveragingStrategy
    dcfr: bool
    predictive: bool
    rmplus: bool
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, *, avg: AveragingStrategy = dh3.AveragingStrategy.LINEAR, alternation: bool = True, dcfr: bool = False, rmplus: bool = False, predictive: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class CornerDhSolver:
    def __init__(self, arg0: CornerDhTraverser, arg1: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class CornerDhState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> CornerDhState:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, arg0: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class CornerDhTraverser:
    def __init__(self) -> None:
        ...
    def construct_uniform_strategies(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def ev_and_exploitability(self, arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, arg0: int) -> Averager:
        ...
    def parent_index_and_action(self, arg0: int, arg1: int) -> tuple[int, int]:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
    @property
    def NUM_INFOS_PL2(self) -> int:
        ...
class DhSolver:
    def __init__(self, arg0: DhTraverser, arg1: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class DhState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> DhState:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, arg0: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class DhTraverser:
    def __init__(self) -> None:
        ...
    def construct_uniform_strategies(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def ev_and_exploitability(self, arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, arg0: int) -> Averager:
        ...
    def parent_index_and_action(self, arg0: int, arg1: int) -> tuple[int, int]:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
    @property
    def NUM_INFOS_PL2(self) -> int:
        ...
class EvExpl:
    def __repr__(self) -> str:
        ...
    @property
    def best_response(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def ev0(self) -> float:
        ...
    @property
    def expl(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def gradient(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
class PtttSolver:
    def __init__(self, arg0: PtttTraverser, arg1: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class PtttState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> PtttState:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, arg0: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class PtttTraverser:
    def __init__(self) -> None:
        ...
    def construct_uniform_strategies(self) -> typing.Annotated[list[numpy.ndarray[numpy.float64]], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def ev_and_exploitability(self, arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, arg0: int) -> Averager:
        ...
    def parent_index_and_action(self, arg0: int, arg1: int) -> tuple[int, int]:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
    @property
    def NUM_INFOS_PL2(self) -> int:
        ...
@typing.overload
def CfrSolver(arg0: DhTraverser, arg1: CfrConf) -> DhSolver:
    ...
@typing.overload
def CfrSolver(arg0: AbruptDhTraverser, arg1: CfrConf) -> AbruptDhSolver:
    ...
@typing.overload
def CfrSolver(arg0: CornerDhTraverser, arg1: CfrConf) -> CornerDhSolver:
    ...
@typing.overload
def CfrSolver(arg0: PtttTraverser, arg1: CfrConf) -> PtttSolver:
    ...
@typing.overload
def CfrSolver(arg0: AbruptPtttTraverser, arg1: CfrConf) -> AbruptPtttSolver:
    ...
